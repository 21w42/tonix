pragma ton-solidity >= 0.64.0;

import "libstring.sol";
import "proc_h.sol";
import "libproc.sol";
import "signal_h.sol";
//import "liberr.sol";

library libsignal {

    uint8 constant ENOENT   = 2; // No such file or directory
    uint8 constant ESRCH    = 3; // No such process
    uint8 constant EINTR    = 4; // Interrupted system call
    uint8 constant ENOSYS   = 78; // Function not implemented
    uint8 constant ERESTART = 1; // restart syscall

    using libsigset for sigset_t;
    using libsigset for uint32;
    uint8 constant SIGHUP   = 1;
    uint8 constant SIGINT   = 2;
    uint8 constant SIGQUIT  = 3;
    uint8 constant SIGILL   = 4;
    uint8 constant SIGTRAP  = 5;
    uint8 constant SIGABRT  = 6;
    uint8 constant SIGBUS   = 7;
    uint8 constant SIGFPE   = 8;
    uint8 constant SIGKILL  = 9;
    uint8 constant SIGUSR1  = 10;
    uint8 constant SIGSEGV  = 11;
    uint8 constant SIGUSR2  = 12;
    uint8 constant SIGPIPE  = 13;
    uint8 constant SIGALRM  = 14;
    uint8 constant SIGTERM  = 15;
    uint8 constant SIGSTKFLT = 16;
    uint8 constant SIGCHLD  = 17;
    uint8 constant SIGCONT  = 18;
    uint8 constant SIGSTOP  = 19;
    uint8 constant SIGTSTP  = 20;
    uint8 constant SIGTTIN  = 21;
    uint8 constant SIGTTOU  = 22;
    uint8 constant SIGURG   = 23;
    uint8 constant SIGXCPU  = 24;
    uint8 constant SIGXFSZ  = 25;
    uint8 constant SIGVTALRM = 26;
    uint8 constant SIGPROF  = 27;
    uint8 constant SIGWINCH = 28;
    uint8 constant SIGIO    = 29;
    uint8 constant SIGPWR   = 30;
    uint8 constant SIGSYS   = 31;
    uint8 constant SIGRTMIN = 34;
    uint8 constant SIGRTMAX = 64;
    string constant ESIGINV = "invalid signal specification";

// Signal properties and actions. The array below categorizes the signals and their default actions
// according to the following properties:
    uint8 constant SIGPROP_KILL	   = 0x01; // terminates process by default
    uint8 constant SIGPROP_CORE	   = 0x02; // ditto and coredumps
    uint8 constant SIGPROP_STOP	   = 0x04; // suspend process
    uint8 constant SIGPROP_TTYSTOP = 0x08; // ditto, from tty
    uint8 constant SIGPROP_IGNORE  = 0x10; // ignore by default
    uint8 constant SIGPROP_CONT	   = 0x20; // continue if suspended

    uint8 constant AFORK   = 0x01; // forked but not exec'ed
    uint8 constant ASU     = 0x02; // used super-user permissions
    uint8 constant ACOMPAT = 0x04; // used compatibility mode
    uint8 constant ACORE   = 0x08; // dumped core
    uint8 constant AXSIG   = 0x10; // killed by a signal
    uint8 constant ANVER   = 0x20; // new record version

    uint8 constant	WCOREFLAG	= 128; //0200;

    uint16 constant SYS_kill         = 37;
    uint16 constant SYS_sigaltstack  = 53;
    uint16 constant SYS_sigprocmask  = 340;
    uint16 constant SYS_sigsuspend   = 341;
    uint16 constant SYS_sigpending   = 343;
    uint16 constant SYS_sigtimedwait = 345;
    uint16 constant SYS_sigwaitinfo  = 346;
    uint16 constant SYS_sigaction    = 416;
    uint16 constant SYS_sigreturn    = 417;
    uint16 constant SYS_sigwait      = 429;
    uint16 constant SYS_sigqueue     = 456;
    uint16 constant SYS_sigfastblock = 573;

    // Fast_sigblock
    uint8 constant SQ_INIT               = 0x01;
    uint8 constant SIGFASTBLOCK_SETPTR   = 1;
    uint8 constant SIGFASTBLOCK_UNBLOCK  = 2;
    uint8 constant SIGFASTBLOCK_UNSETPTR = 3;
    uint8 constant SIGFASTBLOCK_PEND     = 0x1;
    uint8 constant SIGFASTBLOCK_FLAGS    = 0xf;
    uint8 constant SIGFASTBLOCK_INC      = 0x10;

    uint8 constant SIGPROCMASK_OLD  = 	0x0001;
    uint8 constant SIGPROCMASK_PROC_LOCKED  = 0x0002;
    uint8 constant SIGPROCMASK_PS_LOCKED    = 0x0004;
    uint8 constant SIGPROCMASK_FASTBLK  = 0x0008;

    // bits for ksi_flags
    uint8 constant KSI_TRAP     = 0x01; // Generated by trap.
    uint8 constant KSI_EXT      = 0x02; // Externally managed ksi.
    uint8 constant KSI_INS      = 0x04; // Directly insert ksi, not the copy
    uint8 constant KSI_SIGQ     = 0x08; // Generated by sigqueue, might ret EAGAIN.
    uint8 constant KSI_HEAD     = 0x10; // Insert into head, not tail.
    uint8 constant KSI_PTRACE   = 0x20; // Generated by ptrace.
    uint8 constant KSI_COPYMASK = KSI_TRAP | KSI_SIGQ | KSI_PTRACE;

    uint8 constant SIG_DFL      = 0;
    uint8 constant SIG_IGN      = 1;
    uint8 constant SIG_ERR      = 255;
    uint8 constant SIG_CATCH    = 2;
    uint8 constant SIG_HOLD     = 3;
    uint8 constant BADSIG       = SIG_ERR;
    uint8 constant SIGEV_NONE   = 0; // No async notification
    uint8 constant SIGEV_SIGNAL = 1; // Generate a queued signal
    uint8 constant SIGEV_THREAD = 2; // Call back from another pthread
    uint8 constant SIGEV_KEVENT = 3; // Generate a kevent
    uint8 constant SIGEV_THREAD_ID = 4; // Send signal to a kernel thread

    // si_code
    uint8 constant ILL_ILLOPC    = 1;	// Illegal opcode
    uint8 constant ILL_ILLOPN    = 2;	// Illegal operand
    uint8 constant ILL_ILLADR    = 3;	// Illegal addressing mode
    uint8 constant ILL_ILLTRP    = 4;	// Illegal trap
    uint8 constant ILL_PRVOPC    = 5;	// Privileged opcode
    uint8 constant ILL_PRVREG    = 6;	// Privileged register
    uint8 constant ILL_COPROC    = 7;	// Coprocessor error
    uint8 constant ILL_BADSTK    = 8;	// Internal stack error
    uint8 constant BUS_ADRALN    = 1;	// Invalid address alignment
    uint8 constant BUS_ADRERR    = 2;	// Nonexistent physical address
    uint8 constant BUS_OBJERR    = 3;	// Object-specific hardware error
    uint8 constant BUS_OOMERR    = 100;	// Non-standard: No memory
    uint8 constant SEGV_MAPERR   = 1;	// Address not mapped to object
    uint8 constant SEGV_ACCERR   = 2;	// Invalid permissions for mapped object
    uint8 constant SEGV_PKUERR   = 100;	// x86: PKU violation
    uint8 constant FPE_INTOVF    = 1;	// Integer overflow
    uint8 constant FPE_INTDIV    = 2;	// Integer divide by zero
    uint8 constant FPE_FLTDIV    = 3;	// Floating point divide by zero
    uint8 constant FPE_FLTOVF    = 4;	// Floating point overflow
    uint8 constant FPE_FLTUND    = 5;	// Floating point underflow
    uint8 constant FPE_FLTRES    = 6;	// Floating point inexact result
    uint8 constant FPE_FLTINV    = 7;	// Invalid floating point operation
    uint8 constant FPE_FLTSUB    = 8;	// Subscript out of range
    uint8 constant FPE_FLTIDO    = 9;	// Input denormal operation
    uint8 constant TRAP_BRKPT    = 1;	// Process breakpoint.
    uint8 constant TRAP_TRACE    = 2;	// Process trace trap.
    uint8 constant TRAP_DTRACE   = 3;	// DTrace induced trap.
    uint8 constant TRAP_CAP      = 4;	// Capabilities protective trap.
    uint8 constant CLD_EXITED    = 1;	// Child has exited
    uint8 constant CLD_KILLED    = 2;	// Child has terminated abnormally but did not create a core file
    uint8 constant CLD_DUMPED    = 3;	// Child has terminated abnormally and create a core file
    uint8 constant CLD_TRAPPED   = 4;	// Traced child has trapped
    uint8 constant CLD_STOPPED   = 5;	// Child has stopped
    uint8 constant CLD_CONTINUED = 6;	// Stopped child has continued
    uint8 constant POLL_IN       = 1;	// Data input available
    uint8 constant POLL_OUT      = 2;	// Output buffers available
    uint8 constant POLL_MSG      = 3;	// Input message available
    uint8 constant POLL_ERR      = 4;	// I/O Error
    uint8 constant POLL_PRI      = 5;	// High priority input available
    uint8 constant POLL_HUP      = 6;	// Device disconnected

    uint16 constant SA_ONSTACK      = 0x0001;  // take signal on signal stack
    uint16 constant SA_RESTART      = 0x0002;  // restart system call on signal return
    uint16 constant SA_RESETHAND    = 0x0004;  // reset to SIG_DFL when taking signal
    uint16 constant SA_NOCLDSTOP    = 0x0008;  // do not generate SIGCHLD on child stop
    uint16 constant SA_NODEFER      = 0x0010;  // don't mask the signal we're delivering
    uint16 constant SA_NOCLDWAIT    = 0x0020;  // don't keep zombies around
    uint16 constant SA_SIGINFO      = 0x0040;  // signal handler with SA_SIGINFO args
    uint8 constant NSIG             = 32;      // number of old signals (counting 0)
    uint32 constant SI_NOINFO       = 0;       // No signal info besides si_signo.
    uint32 constant SI_USER         = 0x10001; // Signal sent by kill().
    uint32 constant SI_QUEUE        = 0x10002; // Signal sent by the sigqueue().
    uint32 constant SI_TIMER        = 0x10003; // Signal generated by expiration of a timer set by timer_settime().
    uint32 constant SI_ASYNCIO      = 0x10004; // Signal generated by completion of an asynchronous I/O request
    uint32 constant SI_MESGQ        = 0x10005; // Signal generated by arrival of a message on an empty message queue.
    uint32 constant SI_KERNEL       = 0x10006;
    uint32 constant SI_LWP          = 0x10007; // Signal sent by thr_kill
    uint32 constant SI_UNDEFINED    = 0;

    uint16 constant SV_ONSTACK      = SA_ONSTACK;
    uint16 constant SV_INTERRUPT    = SA_RESTART; // same bit, opposite sense
    uint16 constant SV_RESETHAND    = SA_RESETHAND;
    uint16 constant SV_NODEFER      = SA_NODEFER;
    uint16 constant SV_NOCLDSTOP    = SA_NOCLDSTOP;
    uint16 constant SV_SIGINFO      = SA_SIGINFO;
//#define	sigmask(m) (1 << ((m)-1))
// Flags for sigprocmask:
    uint8 constant SIG_BLOCK    = 1; // block specified signal set
    uint8 constant SIG_UNBLOCK  = 2; // unblock specified signal set
    uint8 constant SIG_SETMASK  = 3; // set specified signal set

    uint16 constant PS_NOCLDWAIT = 0x0001; // No zombies if child dies
    uint16 constant PS_NOCLDSTOP = 0x0002; // No SIGCHLD when children stop.
    uint16 constant PS_CLDSIGIGN = 0x0004; // The SIGCHLD handler is SIG_IGN.

    uint8 constant _SIG_WORDS  = 4;
    uint8 constant _SIG_MAXSIG = 128;
//    function f_sigproptbl(uint8 n) internal returns (uint8) {
    uint8[NSIG] constant sigproptbl = [
	SIGPROP_KILL,                   // SIGHUP
	SIGPROP_KILL,                   // SIGINT
	SIGPROP_KILL | SIGPROP_CORE,    // SIGQUIT
	SIGPROP_KILL | SIGPROP_CORE,    // SIGILL
	SIGPROP_KILL | SIGPROP_CORE,    // SIGTRAP
	SIGPROP_KILL | SIGPROP_CORE,    // SIGABRT
	SIGPROP_KILL | SIGPROP_CORE,    // SIGEMT
	SIGPROP_KILL | SIGPROP_CORE,    // SIGFPE
	SIGPROP_KILL,                   // SIGKILL
	SIGPROP_KILL | SIGPROP_CORE,    // SIGBUS
	SIGPROP_KILL | SIGPROP_CORE,    // SIGSEGV
	SIGPROP_KILL | SIGPROP_CORE,    // SIGSYS
	SIGPROP_KILL,                   // SIGPIPE
	SIGPROP_KILL,                   // SIGALRM
	SIGPROP_KILL,                   // SIGTERM
	SIGPROP_IGNORE,                 // SIGURG
	SIGPROP_STOP,                   // SIGSTOP
	SIGPROP_STOP | SIGPROP_TTYSTOP, // SIGTSTP
	SIGPROP_IGNORE | SIGPROP_CONT,  // SIGCONT
	SIGPROP_IGNORE,                 // SIGCHLD
	SIGPROP_STOP | SIGPROP_TTYSTOP, // SIGTTIN
	SIGPROP_STOP | SIGPROP_TTYSTOP, // SIGTTOU
	SIGPROP_IGNORE,                 // SIGIO
	SIGPROP_KILL,                   // SIGXCPU
	SIGPROP_KILL,                   // SIGXFSZ
	SIGPROP_KILL,                   // SIGVTALRM
	SIGPROP_KILL,                   // SIGPROF
	SIGPROP_IGNORE,                 // SIGWINCH
	SIGPROP_IGNORE,                 // SIGINFO
	SIGPROP_KILL,                   // SIGUSR1
	SIGPROP_KILL                    // SIGUSR2
    ];

    using libsignal for s_thread;

    function syscall_nargs(uint16 n) internal returns (uint8) {
        if (n == SYS_sigpending) return 0;
        else if (n == SYS_sigsuspend)
            return 1;
        else if (n == SYS_kill)
            return 2;
        else if (n == SYS_sigaction)
            return 3;
    }
    function syscall_ids() internal returns (uint16[]) {
        return [SYS_kill, SYS_sigaltstack, SYS_sigprocmask, SYS_sigsuspend, SYS_sigpending, SYS_sigtimedwait, SYS_sigwaitinfo, SYS_sigaction, SYS_sigreturn, SYS_sigwait, SYS_sigqueue, SYS_sigfastblock];
    }
    function syscall_name(uint16 number) internal returns (string) {
        if (number == SYS_kill) return "kill";
        if (number == SYS_sigaltstack) return "sigaltstack";
        if (number == SYS_sigprocmask) return "sigprocmask";
        if (number == SYS_sigsuspend) return "sigsuspend";
        if (number == SYS_sigpending) return "sigpending";
        if (number == SYS_sigtimedwait) return "sigtimedwait";
        if (number == SYS_sigwaitinfo) return "sigwaitinfo";
        if (number == SYS_sigaction) return "sigaction";
        if (number == SYS_sigreturn) return "sigreturn";
        if (number == SYS_sigwait) return "sigwait";
        if (number == SYS_sigqueue) return "sigqueue";
        if (number == SYS_sigfastblock) return "sigfastblock";
    }

    function signal_syscall(s_thread td, uint16 number, string[] args) internal {
        td.do_syscall(number, args);
    }

/*
struct siginfo {
    uint8 si_signo;	 // signal number
    uint8 si_errno;	 // errno association
    uint8 si_code;	 // signal code
    uint16 si_pid;	 // sending process
    uint16 si_uid;	 // sender's ruid
    uint8 si_status; // exit value
    uint32 si_addr;	 // faulting instruction
    uint32 si_value; // signal value
    uint32 trapno;  // machine specific trap code
}*/
    function do_syscall(s_thread td, uint16 number, string[] args) internal {
        uint16 rv;
        uint8 ec;
//      s_dirent[] dirents;
//      s_of[] fdt_in = td.td_proc.p_fd.fdt_ofiles;
//      s_of[] fdt;
//      uint len = fdt_in.length;
        uint n_args = args.length;
        string sarg1 = n_args > 0 ? args[0] : "";
        string sarg2 = n_args > 1 ? args[1] : "";
        uint16 arg1 = n_args > 0 ? str.toi(sarg1) : 0;
        uint16 arg2 = n_args > 1 ? str.toi(sarg2) : 0;
        if (arg1 == arg2) {}
        if (number == SYS_kill) {
//            rv = libstat.st_ino(td.td_proc.p_pd.pwd_cdir.attr);
            if (rv > 0)
                ec == 0;
        } else if (number == SYS_sigpending) {

        } else
            ec = ENOSYS;
        td.td_errno = ec;
        td.td_retval = rv;
    }

    function get_no(string sval, string[] sigspec) internal returns (bool success, uint8 no, string name) {
        if (sval.empty())
            return (true, SIGTERM, "TERM");
        for (uint i = 0; i < sigspec.length; i++)
            if (sval == sigspec[i])
                return (true, uint8(i), sval);
        return (false, 0, ESIGINV);
    }

    function get_name(uint8 nval, string[] sigspec) internal returns (bool success, uint8 no, string name) {
        if (nval == 0)
            return (true, SIGTERM, "TERM");
        if (nval > SIGRTMAX)
            return (false, 0, ESIGINV);
        name = nval > SIGRTMAX - 15 ? "RTMAX-" + str.toa(SIGRTMAX - 15 + nval) : nval > SIGRTMIN ? "RTMIN+" + str.toa(nval - SIGRTMIN) : sigspec[nval];
        return (true, nval, name);
    }

    function validate(uint8 nval, string sval, string[] sigspec) internal returns (bool success, uint8 no, string name) {
        if (nval == 0)
            return get_no(sval, sigspec);
        if (sval.empty())
            return get_name(nval, sigspec);
        (bool f1, uint8 n1, string s1) = get_no(sval, sigspec);
        if (!f1)
            return (f1, n1, s1);
        (bool f2, uint8 n2, string s2) = get_name(nval, sigspec);
        if (!f2)
            return (f2, n2, s2);
        if (n1 != n2)
            return (false, n2, s2);
        if (s1 != s2)
            return (false, n2, s2);
        return (true, n1, s1);
    }

// Return the value of the pseudo-expression ((*set & ~*mask) == 0).  This  is an optimized version of SIGISEMPTY() on a temporary variable
// containing SIGSETNAND(*set, *mask).

    function sigsetmasked(uint32 set, uint32 mask) internal returns (bool) {
        return (set & ~mask) > 0;
        /*for (uint i = 0; i < _SIG_WORDS; i++) {
            if (set & ~mask.__bits[i])
                return false;
        }
        return true;*/
    }

//    function __sigisempty(uint32 set) internal returns (bool) {
//        return set > 0;
        /*for (uint i = 0; i < _SIG_WORDS; i++) {
            if (set.__bits[i])
                return false;
        }
        return true;*/
//    }

// Return nonzero if process p has an unmasked pending signal.
//    function SIGPENDING(s_thread td) internal returns (bool) {
//      return ((!__sigisempty(td.td_sigqueue.sq_signals) && !sigsetmasked(td.td_sigqueue.sq_signals, td.td_sigmask)) ||
//	           (!__sigisempty(td.td_proc.p_sigqueue.sq_signals) &&  !sigsetmasked(td.td_proc.p_sigqueue.sq_signals, td.td_sigmask)));
//    }

    function coredump(s_thread td) internal returns (uint8) {}
    function reschedule_signals(s_proc p, sigset_t blk, uint8 flags) internal {}
    function ast_sched(s_thread td, tda tdaa) internal {}
    function sigfastblock_failed(s_thread td, bool fsendsig, bool write) internal  {}
    function sigfastblock_resched(s_thread td, bool resched) internal  {}
    function sigfastblock_setpend1(s_thread td) internal  {}
    function sigfastblock_fetch_sig(s_thread td, bool fsendsig, uint32 valp) internal returns (bool) {}
    function sigdflt(s_sigacts ps, uint8 sig) internal {}
    function proc_set_p2_wexit(s_proc p) internal {}
    function exit1(s_thread td, uint8 rval, uint8 signo) internal {}
    function proc_wkilled(s_proc p) internal {}

    function curthread() internal returns (s_thread) {
    }
    function curproc() internal returns (s_proc) {
    }
    function cursig(s_thread td) internal returns (uint8) {
        return libsigset.SIGPENDING(td) ? issignal(td) : 0;
    }
    function execsigs(s_proc p) internal {}
    function gsignal(uint16 pgid, uint8 sig, ksiginfo ksi) internal {
        s_pgrp pgrp;
        if (pgid > 0) {
            pgrp = libproc.pgfind(pgid);
            if (pgrp.pg_id > 0) {
                pgsignal(pgrp, sig, 0, ksi);
            }
        }
    }
    function killproc(s_proc p, string) internal {
    //	CTR3(KTR_PROC, "killproc: proc %p (pid %d, %s)", p, p->p_pid, p->p_comm);
//    	log(LOG_ERR, "pid %d (%s), jid %d, uid %d, was killed: %s\n", p->p_pid, p->p_comm, p->p_ucred->cr_prison->pr_id, p->p_ucred->cr_uid, why);
    	proc_wkilled(p);
    	kern_psignal(p, SIGKILL);
    }
    function ksiginfo_alloc(uint8) internal returns (ksiginfo) {
        uint8 si_signo;  // signal number
        uint8 si_errno;  // errno association
        uint8 si_code;   // signal code
        uint16 si_pid;   // sending process
        uint16 si_uid;   // sender's ruid
        uint8 si_status; // exit value
        uint32 si_addr;  // faulting instruction
        uint32 si_value; // signal value
        uint32 trapno;   // machine specific trap code
        s_siginfo ssi = s_siginfo(si_signo, si_errno, si_code, si_pid, si_uid, si_status, si_addr, si_value, trapno);
//        ksiginfo
        ssi;
        //return ksiginfo(ssi, KSI_INS);
    }

    /*SIGBUS
    uint8 constant BUS_ADRALN    = 1;	// Invalid address alignment
    uint8 constant BUS_ADRERR    = 2;	// Nonexistent physical address
    uint8 constant BUS_OBJERR    = 3;	// Object-specific hardware error
    uint8 constant BUS_OOMERR    = 100;	// Non-standard: No memory
    uint8 constant SEGV_MAPERR   = 1;	// Address not mapped to object
    uint8 constant SEGV_ACCERR   = 2;	// Invalid permissions for mapped object
    uint8 constant SEGV_PKUERR   = 100;	// x86: PKU violation
    uint8 constant SIGSEGV  = 11;
        uint8 constant SIGIO    = 29;
    uint32 constant SI_NOINFO       = 0;       // No signal info besides si_signo.
    uint32 constant SI_USER         = 0x10001; // Signal sent by kill().
    uint32 constant SI_QUEUE        = 0x10002; // Signal sent by the sigqueue().
    uint32 constant SI_MESGQ        = 0x10005; // Signal generated by arrival of a message on an empty message queue.
    uint32 constant SI_KERNEL       = 0x10006;
    uint32 constant SI_LWP          = 0x10007; // Signal sent by thr_kill
    uint32 constant SI_UNDEFINED    = 0;
    uint8 constant POLL_IN       = 1;	// Data input available
    uint8 constant POLL_OUT      = 2;	// Output buffers available
    uint8 constant POLL_MSG      = 3;	// Input message available
    uint8 constant POLL_ERR      = 4;	// I/O Error
    uint8 constant POLL_PRI      = 5;	// High priority input available
    uint8 constant POLL_HUP      = 6;	// Device disconnected
    uint8 constant SIGALRM  = 14;
    uint32 constant SI_TIMER        = 0x10003; // Signal generated by expiration of a timer set by timer_settime().
    uint32 constant SI_ASYNCIO      = 0x10004; // Signal generated by completion of an asynchronous I/O request
        uint8 constant SIGILL   = 4;
    uint8 constant ILL_ILLOPC    = 1;	// Illegal opcode
    uint8 constant ILL_ILLOPN    = 2;	// Illegal operand
    uint8 constant ILL_ILLADR    = 3;	// Illegal addressing mode
    uint8 constant ILL_ILLTRP    = 4;	// Illegal trap
    uint8 constant ILL_PRVOPC    = 5;	// Privileged opcode
    uint8 constant SIGHUP   = 1;
    uint8 constant SIGTTIN  = 21;
    uint8 constant SIGTTOU  = 22;
    uint8 constant SIGURG   = 23;
    uint8 constant SIGTTIN  = 21;
    uint8 constant SIGTTOU  = 22;
    uint8 constant SIGURG   = 23;
    uint8 constant SIGCHLD  = 17;
    uint8 constant SIGCONT  = 18;
    uint8 constant SIGSTOP  = 19;
    uint8 constant SIGTSTP  = 20;
    uint8 constant CLD_EXITED    = 1;	// Child has exited
    uint8 constant CLD_KILLED    = 2;	// Child has terminated abnormally but did not create a core file
    uint8 constant CLD_STOPPED   = 5;	// Child has stopped
    uint8 constant CLD_CONTINUED = 6;	// Stopped child has continued*/
    function ksiginfo_free(ksiginfo ksi) internal {
    //  uma_zfree(ksiginfo_zone, ksi);
    }
    function pksignal(s_proc p, uint8 sig, ksiginfo ksi) internal returns (uint8) {
	    s_thread td;
        return tdsendsignal(p, td, sig, ksi);
    }
    function pgsigio(s_sigio[] sigiop, uint8 sig, bool checkctty) internal {}
    function pgsignal(s_pgrp pgrp, uint8 sig, uint8 checkctty, ksiginfo ksi) internal {
        if (pgrp.pg_id > 0) {
            for (s_proc p: pgrp.pg_members) {
                if (//p.p_state == PRS_NORMAL &&
                    (checkctty == 0 || (p.p_flag & libproc.P_CONTROLT) > 0))
                    pksignal(p, sig, ksi);
            }
        }
    }
    function postsig(uint8 sig) internal returns (uint16) {}
    function kern_psignal(s_proc p, uint8 sig) internal {
        ksiginfo ksi;
        ksi.ksi_info.si_signo = sig;
        ksi.ksi_info.si_code = uint8(SI_KERNEL & 0xF);
        s_thread td;
        tdsendsignal(p, td, sig, ksi);
    }

    function ptracestop(s_thread td, uint8 sig, ksiginfo si) internal returns (uint16) {}
    function sendsig(uint32 catcher, ksiginfo ksi, uint32 retmask) internal {}
    function sigacts_alloc() internal returns (s_sigacts ps) {
//      ps = malloc(sizeof(struct sigacts), M_SUBPROC, M_WAITOK | M_ZERO);
        ps.ps_refcnt = 1;
        return ps;
    }
    function sigacts_copy(s_sigacts dest, s_sigacts src) internal {
//    	KASSERT(dest.ps_refcnt == 1, "sigacts_copy to shared dest");
//    	bcopy(src, dest, offsetof(struct sigacts, ps_refcnt));
    }
    function sigacts_free(s_sigacts ps) internal {
        if (ps.ps_refcnt-- == 0)
            return;
        //free(ps, M_SUBPROC);
    }
    function sigacts_hold(s_sigacts ps) internal returns (s_sigacts) {
        ps.ps_refcnt++;
	    return ps;
    }
    function sigacts_shared(s_sigacts ps) internal returns (bool) {
	    return ps.ps_refcnt > 1;
    }
    function sig_ast_checksusp(s_thread td) internal returns (uint8 ret) {
        s_proc p;
        p = td.td_proc;
//    	if (!td_ast_pending(td, tda.TDA_SUSPEND))
//          return 0;
//      ret = thread_suspend_check(1);
//      MPASS(ret == 0 || ret == EINTR || ret == ERESTART);
        return ret;
    }
    function sig_ast_needsigchk(s_thread td) internal returns (uint8) {}
    function sig_drop_caught(s_proc p) internal {
//      int sig;
        s_sigacts ps;// = p.p_sigacts;
//          SIG_FOREACH(sig, ps.ps_sigcatch) {
        uint8[] sigs = ps.ps_sigcatch.SIG_FOREACH();
        for (uint8 sig: sigs) {
            sigdflt(ps, sig);
            if ((sigprop(sig) & SIGPROP_IGNORE) > 0)
                sigqueue_delete_proc(p, sig);
        }
    }
    function sigexit(s_thread td, uint8 sig) internal {
	    s_proc p = td.td_proc;
        proc_set_p2_wexit(p);
//          p.p_acflag |= AXSIG;
        if ((sigprop(sig) & SIGPROP_CORE) > 0 &&
           //thread_single(p, libproc.SINGLE_NO_EXIT) == 0) {
              true) {
//          p.p_sig = sig;
        if (coredump(td) == 0)
            sig |= WCOREFLAG;
        }
        exit1(td, 0, sig);
    }
    function sigev_findtd(s_proc, s_sigevent sigev) internal returns (uint8, s_thread[] ttd) {
        s_thread td;
        if (sigev.sigev_notify == SIGEV_THREAD_ID) {
  //        td = tdfind(sigev.sigev_notify_thread_id, p.p_pid);
            if (td.td_tid == 0)
                return (ESRCH, ttd);
        } else {
            delete ttd;
        }
    }
    function sigfastblock_clear(s_thread td) internal {
        bool resched;
        if ((td.td_pflags & libproc.TDP_SIGFASTBLOCK) == 0)
            return;
  //    td.td_sigblock_val = 0;
        resched = (td.td_pflags & libproc.TDP_SIGFASTPENDING) > 0 || libsigset.SIGPENDING(td);
        td.td_pflags &= ~(libproc.TDP_SIGFASTBLOCK | libproc.TDP_SIGFASTPENDING);
        sigfastblock_resched(td, resched);
    }
    function sigfastblock_fetch(s_thread td) internal {
        uint32 val;
        sigfastblock_fetch_sig(td, true, val);
    }
    function sigfastblock_setpend(s_thread td, bool resched) internal {
    	s_proc p;
    	sigfastblock_setpend1(td);
    	if (resched) {
    		p = td.td_proc;
//    		reschedule_signals(p, fastblock_mask, SIGPROCMASK_FASTBLK);
    	}
    }
    function sig_intr() internal returns (uint8 ret) {
    	s_thread td;
    	s_proc p;
    	td = curthread();
//    	if (!td_ast_pending(td, TDA_SIG) && !td_ast_pending(td, TDA_SUSPEND))
//    	    return (0);
    	p = td.td_proc;
    	ret = sig_ast_checksusp(td);
    	if (ret == 0)
    	    ret = sig_ast_needsigchk(td);
    	return ret;
    }
    function siginit(s_proc) internal {
//	    s_sigacts ps = p.p_sigacts;
	    for (uint i = 1; i <= NSIG; i++) {
    //	    if (sigprop(i) & SIGPROP_IGNORE && i != SIGCONT) {
    //	    ps.ps_sigignore.SIGADDSET(i);
    //	    }
	    }
    }
    function signotify(s_thread td) internal {
	    if (libsigset.SIGPENDING(td))
	        ast_sched(td, tda.TDA_SIG);
    }
    function sigqueue_delete(s_sigqueue, uint8 signo) internal {
        sigset_t set;
        set.SIGEMPTYSET();
        set.SIGADDSET(signo);
//      sigqueue_delete_set(sq, &set);
    }
    function sigqueue_delete_proc(s_proc, uint8 signo) internal {
        sigset_t set;
        set.SIGEMPTYSET();
        set.SIGADDSET(signo);
//      sigqueue_delete_set_proc(p, set);
    }
    function sigqueue_flush(s_sigqueue sq) internal {
//      s_proc p;// = sq.sq_proc;
//      ksiginfo ksi;
//      KASSERT(sq.sq_flags & SQ_INIT, ("sigqueue not inited"));
//      if (p.p_pd > 0)
//      PROC_LOCK_ASSERT(p, MA_OWNED);
//      while ((ksi = TAILQ_FIRST(sq.sq_list)) != NULL) {
//          TAILQ_REMOVE(sq.sq_list, ksi, ksi_link);
//          delete ksi.ksi_sigq;
//          if (ksiginfo_tryfree(ksi) > 0 && p.p_pd > 0)
//          p.p_pendingcnt--;
//      }
        sq.sq_signals.SIGEMPTYSET_32();
        sq.sq_kill.SIGEMPTYSET_32();
        sq.sq_ptrace.SIGEMPTYSET_32();
    }
    function sigqueue_init(s_sigqueue list, s_proc p) internal {
        list.sq_signals.SIGEMPTYSET_32();
        list.sq_kill.SIGEMPTYSET_32();
        list.sq_ptrace.SIGEMPTYSET_32();
        list.sq_proc = p.p_pid;
        list.sq_flags = SQ_INIT;
    }
    function sigqueue_take(ksiginfo ksi) internal {}
    function tdksignal(s_thread td, uint8 sig, ksiginfo ksi) internal {
        tdsendsignal(td.td_proc, td, sig, ksi);
    }
    function tdsendsignal(s_proc p, s_thread td, uint8 sig, ksiginfo ksi) internal returns (uint8 ret) {
//    	sig_t action;
        uint8 action;
//    	s_sigaction action;
        s_sigqueue sigqueue;
        uint8 prop;
        s_sigacts ps;
        uint8 intrval;
        uint8 wakeup_swapper;
//    	MPASS(td == NULL || p == td.td_proc);
//    	if (!_SIG_VALID(sig))
//    	    panic("%s(): invalid signal %d", __func__, sig);
//    	KASSERT(ksi == NULL || !KSI_ONQ(ksi), ("%s: ksi on queue", __func__));
        // IEEE Std 1003.1-2001: return success when killing a zombie.
//    	if (p.p_state == p_states.PRS_ZOMBIE) {
        if (ksi.ksi_info.si_signo > 0 && (ksi.ksi_flags & KSI_INS) > 0)
            ksiginfo_tryfree(ksi);
//       	return ret;
//       }
//      ps = p.p_sigacts;
//      KNOTE_LOCKED(p.p_klist, NOTE_SIGNAL | sig);
        prop = sigprop(sig);
        if (td.td_tid == 0) {
            td = sigtd(p, sig, false);
            sigqueue = p.p_sigqueue;
        } else
            sigqueue = td.td_sigqueue;
//    	SDT_PROBE3(proc, , , signal__send, td, p, sig);
        // If the signal is being ignored, then we forget about it immediately, except when the target process executes
        // sigwait().  (Note: we don't set SIGCONT in ps_sigignore, and if it is set to SIG_IGN, action will be SIG_DFL here.)
        if (ps.ps_sigignore.SIGISMEMBER(sig)) {
//          if (kern_sig_discard_ign && (p.p_sysent.sv_flags & SV_SIG_DISCIGN) == 0) {
            if (false) {
//              SDT_PROBE3(proc, , , signal__discard, td, p, sig);
                if (ksi.ksi_info.si_signo > 0 && (ksi.ksi_flags & KSI_INS) > 0)
                    ksiginfo_tryfree(ksi);
                return ret;
        	} else {
                action = SIG_CATCH;
                intrval = 0;
        }
    } else {
        sigset_t sigmask;
        sigmask.SIGSETOLD(td.td_sigmask);
        if (sigmask.SIGISMEMBER(sig))
                action = SIG_HOLD;
        else if (ps.ps_sigcatch.SIGISMEMBER(sig))
            action = SIG_CATCH;
        else
            action = SIG_DFL;
        if (ps.ps_sigintr.SIGISMEMBER(sig))
            intrval = EINTR;
        else
            intrval = ERESTART;
        }
        if ((prop & SIGPROP_CONT) > 0) {}
//          sigqueue_delete_stopmask_proc(p);
        else if ((prop & SIGPROP_STOP) > 0) {
            // If sending a tty stop signal to a member of an orphaned process group, discard the signal here if the action
            // is default; don't stop the process below if sleeping, and don't clear any pending SIGCONT.
            if ((prop & SIGPROP_TTYSTOP) > 0 &&
  //            (p.p_pgrp.pg_flags & libproc.PGRP_ORPHANED) != 0 &&
                   action == SIG_DFL) {
                if (ksi.ksi_info.si_signo > 0 && (ksi.ksi_flags & KSI_INS) > 0)
                    ksiginfo_tryfree(ksi);
                return ret;
            }
            sigqueue_delete_proc(p, SIGCONT);
            if ((p.p_flag & libproc.P_CONTINUED) > 0) {
                p.p_flag &= ~libproc.P_CONTINUED;
//              sigqueue_take(p.p_ksi);
            }
        }
//          ret = sigqueue_add(sigqueue, sig, ksi);
        if (ret != 0)
            return ret;
        signotify(td);
        // Defer further processing for signals which are held, except that stopped processes must be continued by SIGCONT.
        if (action == SIG_HOLD && !((prop & SIGPROP_CONT) > 0 && (p.p_flag & libproc.P_STOPPED_SIG) > 0))
            return ret;
        wakeup_swapper = 0;
        // Some signals have a process-wide effect and a per-thread component.  Most processing occurs when the process next
        // tries to cross the user boundary, however there are some times when processing needs to be done immediately, such as
        // waking up threads so that they can cross the user boundary. We try to do the per-process part here.
        if ((p.p_flag & libproc.P_STOPPED) > 0) {
//       	KASSERT(!(p.p_flag & P_WEXIT), "signal to stopped but exiting process");
            if (sig == SIGKILL) {
                // If traced process is already stopped, then no further action is necessary.
                if ((p.p_flag & libproc.P_TRACED) > 0)
                    return ret;
                // SIGKILL sets process running. It will die elsewhere. All threads must be restarted.
                p.p_flag &= ~libproc.P_STOPPED_SIG;
  //            goto runfast;
            }
            if ((prop & SIGPROP_CONT) > 0) {
                // If traced process is already stopped, then no further action is necessary.
                if ((p.p_flag & libproc.P_TRACED) > 0)
                    return ret;
                //If SIGCONT is default (or ignored), we continue the process but don't leave the signal in sigqueue as
                // it has no further action.  If SIGCONT is held, we continue the process and leave the signal in
                // sigqueue.  If the process catches SIGCONT, let it handle the signal itself.  If it isn't waiting on
                // an event, it goes back to run state. Otherwise, process goes back to sleep state.
                p.p_flag &= ~libproc.P_STOPPED_SIG;
                if (p.p_numthreads == 1 ) { //p.p_suspcount
                    p.p_flag |= libproc.P_CONTINUED;
                    p.p_xsig = SIGCONT;
//                  childproc_continued(p);
                }
                if (action == SIG_DFL) {
//                  thread_unsuspend(p);
                    sigqueue_delete(sigqueue, sig);
                    //goto out_cont;
                }
                if (action == SIG_CATCH) {
                    // The process wants to catch it so it needs to run at least one thread, but which one?
                    //goto runfast;
                }
                // The signal is not ignored or caught.
//                  thread_unsuspend(p);
//                  continue;
            }
            if ((prop & SIGPROP_STOP) > 0) {
                // If traced process is already stopped, then no further action is necessary.
                if ((p.p_flag & libproc.P_TRACED) > 0)
                    return ret;
                // Already stopped, don't need to stop again (If we did the shell could get confused).
                // Just make sure the signal STOP bit set.
                p.p_flag |= libproc.P_STOPPED_SIG;
                sigqueue_delete(sigqueue, sig);
                return ret;
            }
            // All other kinds of signals: If a thread is sleeping interruptibly, simulate a wakeup so that when it is continued it will be made
            // runnable and can look at the signal.  However, don't make the PROCESS runnable, leave it stopped. It may run a bit until it hits a thread_suspend_check().
//              if (TD_CAN_ABORT(td))
//              wakeup_swapper = sig_sleepq_abort(td, intrval);
            return ret;
        } else if (/*p.p_state == p_states.PRS_NORMAL*/ true) {
            if ((p.p_flag & libproc.P_TRACED) > 0 || action == SIG_CATCH) {
                //tdsigwakeup(td, sig, action, intrval);
                return ret;
            }
            if ((prop & SIGPROP_STOP) > 0) {
                if ((p.p_flag & (libproc.P_PPWAIT | libproc.P_WEXIT)) > 0)
                    return ret;
                p.p_flag |= libproc.P_STOPPED_SIG;
                p.p_xsig = sig;
                wakeup_swapper;// = sig_suspend_threads(td, p);
                if (p.p_numthreads == 1 /*p.p_suspcount*/) {
                    // only thread sending signal to another process can reach here, if thread is sending signal to its process, because thread does
                    // not suspend itself here, p_numthreads should never be equal to p_suspcount.
//                  thread_stopped(p);
                    sigqueue_delete_proc(p, p.p_xsig);
                } else
                    return ret;
            }
        } else {
            // Not in "NORMAL" state. discard the signal
            sigqueue_delete(sigqueue, sig);
        }

        // The process is not stopped so we need to apply the signal to all the running threads.
//    runfast:
//      tdsigwakeup(td, sig, action, intrval);
//      thread_unsuspend(p);
//   out_cont:
//      itimer_proc_continue(p);
//      kqtimer_proc_continue(p);
//    out:
//      if (wakeup_swapper)
//    	    kick_proc0();
//      return (ret);
    }
    function tdsigcleanup(s_thread td) internal {}
    function tdsignal(s_thread td, uint8 sig) internal {
        ksiginfo ksi;
//      ksiginfo_init(ksi);
        ksi.ksi_info.si_signo = sig;
        ksi.ksi_info.si_code = uint8(SI_KERNEL & 0xF);
        tdsendsignal(td.td_proc, td, sig, ksi);
    }
    function trapsignal(s_thread td, ksiginfo ksi) internal {}

    enum sigstatus {
        SIGSTATUS_HANDLE,
        SIGSTATUS_HANDLED,
        SIGSTATUS_IGNORE,
        SIGSTATUS_SBDRY_STOP
    }

    function issignal(s_thread td) internal returns (uint8 sig) {
        sigset_t sigpending;
        s_proc p = td.td_proc;
        for (;;) {
            sigset_t td_sq_signals;
            td_sq_signals.SIGSETOLD(td.td_sigqueue.sq_signals);
        	sigpending = td_sq_signals;
            sigset_t p_sq_signals;
            p_sq_signals.SIGSETOLD(p.p_sigqueue.sq_signals);
        	sigpending.SIGSETOR(p_sq_signals);
            sigset_t td_sigmask;
            td_sigmask.SIGSETOLD(td.td_sigmask);
        	sigpending.SIGSETNAND(td_sigmask);
       	    if ((p.p_flag & libproc.P_PPWAIT) != 0 || (td.td_flags &
       	        (libproc.TDF_SBDRY | libproc.TDF_SERESTART | libproc.TDF_SEINTR)) == libproc.TDF_SBDRY)
       	        sigpending.SIG_STOPSIGMASK();
       	    if (sigpending.SIGISEMPTY())	/* no signal to send */
       	        return 0;
            // Do fast sigblock if requested by usermode.  Since we do know that there was a signal pending at this
            // point, set the FAST_SIGBLOCK_PEND as indicator for usermode to perform a dummy call to
            // FAST_SIGBLOCK_UNBLOCK, which causes immediate delivery of postponed pending signal.
            if ((td.td_pflags & libproc.TDP_SIGFASTBLOCK) != 0) {
//    	        if (td.td_sigblock_val != 0)
//    	            sigpending.SIGSETNAND(fastblock_mask);
                if (sigpending.SIGISEMPTY()) {
                    td.td_pflags |= libproc.TDP_SIGFASTPENDING;
                    return 0;
                }
            }
            if ((p.p_flag & (libproc.P_TRACED | libproc.P_PPTRACE)) == libproc.P_TRACED &&
//              (p.p_flag2 & P2_PTRACE_FSTP) != 0 &&
                sigpending.SIGISMEMBER(SIGSTOP)) {
                // If debugger just attached, always consume SIGSTOP from ptrace(PT_ATTACH) first, to
                // execute the debugger attach ritual in  order.
//                  td.td_dbgflags |= libproc.TDB_FSTP;
                sigpending.SIGEMPTYSET();
                sigpending.SIGADDSET(SIGSTOP);
            }
            uint8[] sigs = sigpending.SIG_FOREACH();
            for (uint8 sigg:  sigs) {
                sigstatus ss;// = sigprocess(td, sigg);
                if (ss == sigstatus.SIGSTATUS_HANDLE)
                    return sigg;
                else if (ss == sigstatus.SIGSTATUS_HANDLED)
                    continue;
                else if (ss == sigstatus.SIGSTATUS_IGNORE) {
                    sigqueue_delete(td.td_sigqueue, sigg);
                    sigqueue_delete(p.p_sigqueue, sigg);
                    break;
                } else if (ss == sigstatus.SIGSTATUS_SBDRY_STOP)
                    return 255;
            }
        }
    }
    function ksiginfo_tryfree(ksiginfo ksi) internal returns (uint8) {
        if ((ksi.ksi_flags & KSI_EXT) > 0) {
//          uma_zfree(ksiginfo_zone, ksi);
            return 1;
        }
        return 0;
    }

    function sigtd(s_proc, uint8 sig, bool) internal returns (s_thread signal_td) {
        s_thread td;
        s_thread tcurthread = curthread();
        if (!tcurthread.td_sigmask.SIGISMEMBER0(sig))
               return td;
        // Check if current thread can handle the signal without switching context to another thread.
//       if (curproc == p && !SIGISMEMBER(curthread.td_sigmask, sig) &&
//           (!fast_sigblock || curthread.td_sigblock_val == 0))
//          return curthread;
//          delete signal_td;
//          FOREACH_THREAD_IN_PROC(p, td) {
//       if (!SIGISMEMBER(td.td_sigmask, sig) && (!fast_sigblock ||
//              td != curthread || td.td_sigblock_val == 0)) {
//              signal_td = td;
//              break;
//          }
//       }
//       if (signal_td == 0)
//       	signal_td = FIRST_THREAD_IN_PROC(p);
        return signal_td;
    }

    function sigprop(uint8 sig) internal returns (uint8) {
        if (sig > 0 && sig < sigproptbl.length)
            return sigproptbl[sig];
        return 0;
    }
}

library libsigset {

    using libsigset for sigset_t;
//    uint8 constant _SIG_WORDS	= 4;
    uint8 constant _SIG_WORDS	= 1;
//    uint8 constant _SIG_MAXSIG	= 128;
    uint8 constant _SIG_MAXSIG = 31;

    function _SIG_FOREACH_ADVANCE(uint32 __bits) internal returns (uint[] res) {
        if (__bits > 0)
            for (uint i = 0; i < 0xFFFFFFFF; i << 1)
                if ((__bits & i) > 0)
                    res.push(i);
    }

    function SIG_FOREACH_32(uint set) internal returns (uint8[] ret) {
        while (set > 0) {
            uint res = uBitSize(set);
            if (res > 0) {
                ret.push(uint8(res - 1));
                set &= res << 1;
            } else
                return ret;
        }
    }

    function SIGEMPTYSET_32(uint32 set) internal {
        set = 0;
    }

    function SIG_FOREACH(sigset_t set) internal returns (uint8[] ret) {
    	for (uint i = 0; i < _SIG_WORDS; i++) {
            uint[] res = _SIG_FOREACH_ADVANCE(set.__bits[i]);
            for (uint s: res)
                ret.push(uint8(s));
        }
    }


    function SIGPENDING(s_thread td) internal returns (bool) {
        sigset_t td_sigqueue;
        td_sigqueue.SIGSETOLD(td.td_sigqueue.sq_signals);
        sigset_t p_sigqueue;
        p_sigqueue.SIGSETOLD(td.td_proc.p_sigqueue.sq_signals);
        sigset_t td_sigmask;
        td_sigmask.SIGSETOLD(td.td_sigmask);
        return ((!__sigisempty(td_sigqueue) && !__sigsetmasked(td_sigqueue, td_sigmask)) ||
	        (!__sigisempty(p_sigqueue) &&  !__sigsetmasked(p_sigqueue, td_sigmask)));
    }

    function _SIG_IDX(uint8 sig) internal returns (uint8) {
        return sig - 1;
    }
    function _SIG_WORD(uint8 sig) internal returns (uint8) {
        return _SIG_IDX(sig) >> 5;
    }
    function _SIG_BIT(uint8 sig) internal returns (uint8) {
        return uint8(uint(1) << _SIG_IDX(sig) & 31);
    }
    function _SIG_VALID(uint8 sig) internal returns (bool) {
        return sig <= _SIG_MAXSIG && sig > 0;
    }

    function __sigisempty(sigset_t set) internal returns (bool) {
        for (uint i = 0; i < _SIG_WORDS; i++) {
            if (set.__bits[i] > 0)
                return false;
        }
        return true;
    }

    function __sigseteq(sigset_t set1, sigset_t set2) internal returns (bool) {
        for (uint i = 0; i < _SIG_WORDS; i++) {
            if (set1.__bits[i] != set2.__bits[i])
                return false;
        }
        return true;
    }

    // Return the value of the pseudo-expression ((*set & ~*mask) == 0).  This is an optimized version of SIGISEMPTY() on a temporary variable
    // containing SIGSETNAND(*set, *mask).
    function __sigsetmasked(sigset_t set, sigset_t mask) internal returns (bool) {
        for (uint i = 0; i < _SIG_WORDS; i++) {
            if ((set.__bits[i] & ~mask.__bits[i]) > 0)
                return false;
        }
        return true;
    }

    function SIGADDSET(sigset_t set, uint8 signo) internal {
        set.__bits[_SIG_WORD(signo)] |= _SIG_BIT(signo);
    }
    function SIGDELSET(sigset_t set, uint8 signo) internal {
        set.__bits[_SIG_WORD(signo)] &= ~_SIG_BIT(signo);
    }
    function SIGEMPTYSET(sigset_t set) internal {
        for (uint __i = 0; __i < _SIG_WORDS; __i++)
            set.__bits[__i] = 0;
    }

    function SIGFILLSET(sigset_t set) internal {
        for (uint __i = 0; __i < _SIG_WORDS; __i++)
    		set.__bits[__i] = 0xFFFFFFFF;
    }
    function SIGISMEMBER0(uint32 v, uint8 signo) internal returns (bool) {
        sigset_t sigmask;
        sigmask.SIGSETOLD(v);
        return sigmask.SIGISMEMBER(signo);
    }
    function SIGISMEMBER(sigset_t set, uint8 signo) internal returns (bool)   {
        return (set.__bits[_SIG_WORD(signo)] & _SIG_BIT(signo)) > 0;
    }
    function SIGISEMPTY(sigset_t set)internal returns (bool) {
        return __sigisempty(set);
    }
    function SIGNOTEMPTY(sigset_t set) internal returns (bool)  {
        return !__sigisempty(set);
    }
    function SIGSETEQ(sigset_t set1, sigset_t set2) internal returns (bool) {
          return __sigseteq(set1, set2);
    }
    function SIGSETNEQ(sigset_t set1, sigset_t set2) internal returns (bool) {
         return !__sigseteq(set1, set2);
    }
    function SIGSETOR(sigset_t set1, sigset_t set2) internal {
        for (uint __i = 0; __i < _SIG_WORDS; __i++)
            set1.__bits[__i] |= set2.__bits[__i];
    }
    function SIGSETAND(sigset_t set1, sigset_t set2) internal {
        for (uint __i = 0; __i < _SIG_WORDS; __i++)
            set1.__bits[__i] &= set2.__bits[__i];
    }
    function SIGSETNAND(sigset_t set1, sigset_t set2) internal {
        for (uint __i = 0; __i < _SIG_WORDS; __i)
            set1.__bits[__i] &= ~set2.__bits[__i];
    }
    function SIGSETLO(sigset_t set1, sigset_t set2) internal {
        set1.__bits[0] = set2.__bits[0];
    }
    function SIGSETOLD(sigset_t set, uint32 oset) internal {
         set.__bits[0] = oset;
    }
    function SIG_CANTMASK(sigset_t set) internal {
        set.SIGDELSET(libsignal.SIGKILL);
        set.SIGDELSET(libsignal.SIGSTOP);
    }
    function SIG_STOPSIGMASK(sigset_t set) internal {
        set.SIGDELSET(libsignal.SIGSTOP);
        set.SIGDELSET(libsignal.SIGTSTP);
        set.SIGDELSET(libsignal.SIGTTIN);
        set.SIGDELSET(libsignal.SIGTTOU);
    }
    function SIG_CONTSIGMASK(sigset_t set) internal {
        set.SIGDELSET(libsignal.SIGCONT);
    }
}
  /*uint8 constant SIGRTMIN+1 = 35;
  uint8 constant SIGRTMIN+2   = 36;
  uint8 constant SIGRTMIN+3   = 37;
  uint8 constant SIGRTMIN+4   = 38;
  uint8 constant SIGRTMIN+5   = 39;
  uint8 constant SIGRTMIN+6   = 40;
  uint8 constant SIGRTMIN+7   = 41;
  uint8 constant SIGRTMIN+8   = 42;
  uint8 constant SIGRTMIN+9   = 43;
  uint8 constant SIGRTMIN+10  = 44;
  uint8 constant SIGRTMIN+11  = 45;
  uint8 constant SIGRTMIN+12  = 46;
  uint8 constant SIGRTMIN+13  = 47;
  uint8 constant SIGRTMIN+14  = 48;
  uint8 constant SIGRTMIN+15  = 49;
  uint8 constant SIGRTMAX-14  = 50;
  uint8 constant SIGRTMAX-13  = 51;
  uint8 constant SIGRTMAX-12  = 52;
  uint8 constant SIGRTMAX-11  = 53;
  uint8 constant SIGRTMAX-10  = 54;
  uint8 constant SIGRTMAX-9   = 55;
  uint8 constant SIGRTMAX-8   = 56;
  uint8 constant SIGRTMAX-7   = 57;
  uint8 constant SIGRTMAX-6   = 58;
  uint8 constant SIGRTMAX-5   = 59;
  uint8 constant SIGRTMAX-4   = 60;
  uint8 constant SIGRTMAX-3   = 61;
  uint8 constant SIGRTMAX-2   = 62;
  uint8 constant SIGRTMAX-1   = 63;*/